@page "/pie"

@inject IJSRuntime jsRuntime;

<style>
    .path {
        pointer-events: all;
        transition: all .6s;
    }

        .path:hover {
            cursor: pointer;
        }
</style>

<div>@total</div>
@foreach (var d in Data)
{
    <p>@d</p>
}


<svg width="@Size" height="@Size" id="pie-chart">
    @for (var i = 0; i < Data.Count; i++)
    {
        int j = i;
        <text>
            <text x="@(GetLabelPoints(i).Split(',')[0])" y="@(GetLabelPoints(i).Split(',')[1])" style="font-size:40px; color:#fff; ">@(Data[i])</text>
        </text>
        <path class="path" id="@($"path-{i}")" d="@GetPath(i, false)"
              style="fill:@Colors[i];
        fill-opacity: 1" @onmouseover="() => OnPathHover(j)" @onmouseout="() => OnPathLeave(j)" />
    }
</svg>




@code {
    [Parameter]
    public List<double> Data { get; set; } = new() { 5, 70, 20, 22 };

    [Parameter]
    public double Size { get; set; } = 400;

    [Parameter]
    public List<string>
    Colors
    { get; set; } = new() { "#1365fc", "#298a00", "#fe00ff", "#ff5a5a", "#fffa06", "#01f4f1", "#C608D1", "#2900A5", "#FFA9FD", "#E4BF58", "#C94D6D", "#A9A9A9", "#BE61CA" };

    public double Radius { get; set; }

    public double Padding { get; set; } = 0;

    public double Circumference { get; set; } = (2 * Math.PI) * 125;

    public double total { get; set; }

    protected override void OnParametersSet()
    {
        Radius = (Size * .9) / 2;
        Padding = (Size * .1) / 2;
        total = Data.Sum();
    }

    private string GetPoints(int index)
    {
        double val = Data[index];

        if (index == Data.Count - 1)
        {
            return $"{Padding},{Size / 2}";
        };

        for (var i = 0; i < index; i++)
        {
            val += Data[i];
        }

        var angle = (val / total) * (2 * Math.PI);
        var sin = Math.Sin(angle);
        var cosine = Math.Cos(angle);
        var x = Size / 2 - (cosine * Radius);
        var y = Size / 2 - (sin * Radius);
        return $"{x},{y}";
    }

    private string GetLabelPoints(int index)
    {
        double val = Data[index];
        val = val / 2;

        if (index == Data.Count - 1)
        {
            return $"{(Size * .4) / 2},200";
        };

        for (var i = 0; i < index; i++)
        {
            val += Data[i];
        }

        var angle = (val / total) * (2 * Math.PI);
        var sin = Math.Sin(angle);
        var cosine = Math.Cos(angle);
        var x = Size / 2 - (cosine * (Size * .4 / 2));
        var y = Size / 2 - (sin * (Size * .4 / 2));
        return $"{x},{y}";
    }

    private string GetHoverPoints(int index)
    {
        double val = Data[index];

        if (index == Data.Count - 1)
        {
            return $"{0},{Size / 2}";
        };

        for (var i = 0; i < index; i++)
        {
            val += Data[i];
        }

        var angle = (val / total) * (2 * Math.PI);
        var sin = Math.Sin(angle);
        var cosine = Math.Cos(angle);
        var x = Size / 2 - (cosine * (Size / 2));
        var y = Size / 2 - (sin * (Size / 2));
        return $"{x},{y}";
    }

    private string getParentCord(int index, bool hover)
    {
        if (index == 0)
        {
            if (hover)
            {
                return $"{0},{Size / 2}";
            }
            return $"{Padding},{Size / 2}";
        }
        else
        {
            if (hover)
            {
                return GetHoverPoints(index - 1);
            }
            return GetPoints(index - 1);
        }
    }

    private int CheckIfLarge(int index)
    {
        if (Data[index] / total > .5)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }

    private string GetPath(int index, bool hover)
    {
        if (hover)
        {
            return $"M{Size / 2},{Size / 2 } L{getParentCord(index, true)} A{Size / 2},{Size / 2} 0 {CheckIfLarge(index)},1 {GetHoverPoints(index)} Z";
        }
        return $"M{Size / 2},{Size / 2 } L{getParentCord(index, false)} A{Radius},{Radius} 0 {CheckIfLarge(index)},1 {GetPoints(index)} Z";
    }

    private async Task OnPathHover(int index)
    {
        var newPath = GetPath(index, true);
        await jsRuntime.InvokeVoidAsync("SetPath", $"path-{index}", newPath);
    }

    private async Task OnPathLeave(int index)
    {
        var newPath = GetPath(index, false);
        await jsRuntime.InvokeVoidAsync("SetPath", $"path-{index}", newPath);

    }
}
